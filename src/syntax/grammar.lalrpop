use crate::syntax::{ast, token};

grammar;

pub Stmt = {
    StmtExpr,
    StmtPrint,
    StmtVar,
}

StmtExpr: ast::Stmt =
    <expr:Expr> ";" => ast::Stmt::Expr(ast::StmtExpr { <> });

StmtPrint: ast::Stmt =
    "print" <expr:Expr> ";" => ast::Stmt::Print(ast::StmtPrint { <> });

StmtVar: ast::Stmt =
    "var" <name:"identifier"> "=" <expr:Expr> ";" =>
        ast::Stmt::Var(ast::StmtVar { <> });

pub Expr = ExprLogicOr;

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;

ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Subtract,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Multiply,
    "/" => ast::OpInfix::Divide,
}

ExprPrefix: ast::Expr = {
    <op:OpPrefix> <expr:ExprPrefix> =>
        ast::Expr::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprPrimary,
}
OpPrefix: ast::OpPrefix = {
    "-" => ast::OpPrefix::Negate,
    "!" => ast::OpPrefix::Not,
}

ExprPrimary: ast::Expr = {
    <ExprLiteral> => ast::Expr::Literal(<>),
    "(" <Expr> ")",
}

ExprLiteral: ast::ExprLiteral = {
    "nil" => ast::ExprLiteral::Nil,
    "false" => ast::ExprLiteral::Bool(false),
    "true" => ast::ExprLiteral::Bool(true),
    "string" => ast::ExprLiteral::String(<>),
    "number" => ast::ExprLiteral::Number(<>),
}

ExprInfix<Lt, Op, Rt>: ast::Expr = {
    <lt:Lt> <op:Op> <rt:Rt> =>
        ast::Expr::Infix(Box::new(ast::ExprInfix { <> })),
    Rt,
}

extern {
    type Location = usize;
    type Error = anyhow::Error;

    enum token::Token {
        // Single-character tokens.
        "(" => token::Token::LtParen,
        ")" => token::Token::RtParen,
        "{" => token::Token::LtBrace,
        "}" => token::Token::RtBrace,
        "," => token::Token::Comma,
        "." => token::Token::Dot,
        "-" => token::Token::Minus,
        "+" => token::Token::Plus,
        ";" => token::Token::Semicolon,
        "/" => token::Token::Slash,
        "*" => token::Token::Asterisk,

        // One or two character tokens.
        "!" => token::Token::Bang,
        "!=" => token::Token::BangEqual,
        "=" => token::Token::Equal,
        "==" => token::Token::EqualEqual,
        ">" => token::Token::Greater,
        ">=" => token::Token::GreaterEqual,
        "<" => token::Token::Less,
        "<=" => token::Token::LessEqual,

        // Literals.
        "identifier" => token::Token::Identifier(<String>),
        "string" => token::Token::String(<String>),
        "number" => token::Token::Number(<f64>),

        // Keywords.
        "and" => token::Token::And,
        "class" => token::Token::Class,
        "else" => token::Token::Else,
        "false" => token::Token::False,
        "for" => token::Token::For,
        "fun" => token::Token::Fun,
        "if" => token::Token::If,
        "nil" => token::Token::Nil,
        "or" => token::Token::Or,
        "print" => token::Token::Print,
        "return" => token::Token::Return,
        "super" => token::Token::Super,
        "this" => token::Token::This,
        "true" => token::Token::True,
        "var" => token::Token::Var,
        "while" => token::Token::While,
    }
}
